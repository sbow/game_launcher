{
  "directories": [
    "src",
    "src/types",
    "src/widgets",
    "src/scenes",
    "public",
    "public/assets",
    "public/assets/video",
    "public/assets/fonts",
    "public/assets/skies",
    "public/assets/shaders",
    "public/assets/audio",
    "public/assets/sprites",
    "public/assets/sprites/asteroids"
  ],
  "files": [
    "README.md",
    "tsconfig.json",
    "package-lock.json",
    "webpack.config.js",
    "package.json",
    "results.json",
    "src/index.ts",
    "src/types/MenuItems.ts",
    "src/types/MultChoice.ts",
    "src/widgets/ControlPanel.ts",
    "src/scenes/MultChoiceScene.ts",
    "src/scenes/AsteroidsScene.ts",
    "src/scenes/RobotEqScene.ts",
    "src/scenes/MenuScene.ts",
    "public/index.html",
    "public/assets/video/robot-dance.webm",
    "public/assets/fonts/knight3.png",
    "public/assets/skies/space3.png",
    "public/assets/shaders/bundle4.glsl.js",
    "public/assets/audio/training-program-correct2-88734.mp3",
    "public/assets/audio/buzzer-or-wrong-answer-20582.mp3",
    "public/assets/audio/aquakitty-kittyrock.m4a",
    "public/assets/sprites/button-bg.png",
    "public/assets/sprites/thrust_ship2.png",
    "public/assets/sprites/home_128x128.png",
    "public/assets/sprites/asteroids/a10004.png",
    "public/assets/sprites/asteroids/readme.txt",
    "public/assets/sprites/asteroids/a40002.png",
    "public/assets/sprites/asteroids/a30010.png",
    "public/assets/sprites/asteroids/a10013.png"
  ],
  "file_contents": {
    "tsconfig.json": "{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  }\n}\n",
    "package.json": "{\n  \"name\": \"game_launcher\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"webpack serve --mode development\",\n    \"build\": \"webpack --mode production\",\n    \"clean\": \"rm -rf dist\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"phaser\": \"^3.70.0\"\n  },\n  \"devDependencies\": {\n    \"typescript\": \"^5.3.3\",\n    \"ts-loader\": \"^9.5.1\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"webpack-dev-server\": \"^4.15.1\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"html-webpack-plugin\": \"^5.5.0\",\n    \"@types/node\": \"^20.10.0\"\n  }\n}",
    "src/index.ts": "import 'phaser';\nimport { MenuScene } from './scenes/MenuScene';\nimport { RobotEqScene } from './scenes/RobotEqScene';\nimport { MultChoiceScene } from './scenes/MultChoiceScene';\nimport { AsteroidsScene } from './scenes/AsteroidsScene';\n\n//https://docs.phaser.io/api-documentation/typedef/types-core\nconst config: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 600,\n    scene: [MenuScene, RobotEqScene, MultChoiceScene, AsteroidsScene],\n    backgroundColor: '#000000',\n    scale: {\n        mode: Phaser.Scale.FIT,\n        autoCenter: Phaser.Scale.CENTER_BOTH\n    },\n    audio: {\n        disableWebAudio: false,\n        noAudio: false\n    },\n};\n\n// Create game instance\nconst game = new Phaser.Game(config);",
    "src/types/MenuItems.ts": "// MenuItems.ts\n// A dataclass for menu trees\n\nexport enum MenuItemEnum {\n    MultChoice,\n    Asteroids,\n    RobotEqScene,\n}\n\nexport interface MenuItems {\n    item: MenuItemEnum;\n    text: string;\n    scene_key?: string; // ie: set in constructor(), key: 'MyScene'\n    visited?: boolean; // ie: set to True if it's been visited\n}\n\nexport const STARTMENU: MenuItems[] = [\n    {\n        item: MenuItemEnum.MultChoice,\n        text: \"Multiple Choice\",\n    },\n    {\n        item: MenuItemEnum.Asteroids,\n        text: \"Asteroids\",\n    },\n    {\n        item: MenuItemEnum.RobotEqScene,\n        text: \"Robot Dance Party\",\n    }\n]",
    "src/types/MultChoice.ts": "export interface MultChoice {\n    text: string;\n    options: string[];\n    correctAnswer: number;\n}\n\nexport const FAMILYMC: MultChoice[] = [\n    {\n        text: \"What is a rainbow?\",\n        options: [\"Magic\", \"Radio Wave Arch\", \"Sprinkle Water Arch\", \"Frozen Water Arch\"],\n        correctAnswer: 2\n    },\n    {\n        text: \"What do you call mumma's mumma?\",\n        options: [\"Gramy\", \"Grandma\", \"Mimi\", \"Papa\"],\n        correctAnswer: 2\n    },\n    {\n        text: \"What does mumma call mumma's mumma?\",\n        options: [\"Mom\", \"Gramy\", \"Mimi\", \"Dad\"],\n        correctAnswer: 0\n    },\n    {\n        text: \"Which planet is closest to the Sun?\",\n        options: [\"Venus\", \"Mercury\", \"Mars\", \"Earth\"],\n        correctAnswer: 1\n    },\n    {\n        text: \"What is 2 + 2?\",\n        options: [\"3\", \"4\", \"5\", \"6\"],\n        correctAnswer: 1\n    },\n    {\n        text: \"What color is the sky?\",\n        options: [\"Red\", \"Green\", \"Blue\", \"Yellow\"],\n        correctAnswer: 2\n    }\n];\n",
    "src/widgets/ControlPanel.ts": "interface ControlPanelConfig {\n    scene: Phaser.Scene;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    padding?: number;\n    buttonSpacing?: number;\n    backgroundColor?: number;\n    backgroundAlpha?: number;\n}\n\nexport class ControlPanel {\n    private scene: Phaser.Scene;\n    private container: Phaser.GameObjects.Container;\n    private background: Phaser.GameObjects.Rectangle;\n    private controls: Phaser.GameObjects.Image[];\n    private padding: number;\n    private buttonSpacing: number;\n    private currentX: number;\n    private currentY: number;\n\n    constructor(config: ControlPanelConfig) {\n        this.scene = config.scene;\n        this.controls = [];\n        \n        // Set default values\n        this.padding = config.padding ?? 20;\n        this.buttonSpacing = config.buttonSpacing ?? 10;\n        \n        // Create container\n        this.container = this.scene.add.container(config.x, config.y);\n        \n        // Add background panel\n        this.background = this.scene.add.rectangle(\n            0,\n            0,\n            config.width,\n            config.height,\n            config.backgroundColor ?? 0x333333,\n            config.backgroundAlpha ?? 0.8\n        );\n        this.container.add(this.background);\n        \n        // Initialize current position\n        this.currentX = this.padding;\n        this.currentY = this.padding;\n    }\n    \n    addControl(\n        imageKey: string,\n        callback: () => void,\n        scale: number = 1.0,\n    ): Phaser.GameObjects.Image {\n        const control = this.scene.add.image(0, 0, imageKey)\n            .setInteractive()\n            .setScale(scale);\n            \n        // Center the control in its grid cell\n        control.x = -this.currentX - this.padding / 2;\n        control.y = this.currentY + this.padding / 2;\n        \n        // Add interaction handlers\n        control.on('pointerdown', () => {\n            control.setScale(scale * 0.9);\n            callback();\n        });\n        \n        control.on('pointerup', () => {\n            control.setScale(scale);\n        });\n        \n        control.on('pointerout', () => {\n            control.setScale(scale);\n        });\n        \n        // Add to container\n        this.container.add(control);\n        this.controls.push(control);\n        \n        // Update position for next control\n        this.currentX += control.displayWidth + this.buttonSpacing;\n        \n        // If we exceed panel width, move to next row\n        if (this.currentX + control.displayWidth + this.padding > this.background.width) {\n            this.currentX = this.padding;\n            this.currentY += control.displayHeight + this.buttonSpacing;\n        }\n        \n        return control;\n    }\n\n    // Additional utility methods\n    setVisible(visible: boolean): void {\n        this.container.setVisible(visible);\n    }\n\n    setPosition(x: number, y: number): void {\n        this.container.setPosition(x, y);\n    }\n\n    destroy(): void {\n        this.container.destroy();\n    }\n}",
    "src/scenes/MultChoiceScene.ts": "import { MultChoice, FAMILYMC } from '../types/MultChoice';\nimport { ControlPanel } from '../widgets/ControlPanel'\n\nexport class MultChoiceScene extends Phaser.Scene {\n    private controlPanel?: ControlPanel;\n    private score: number = 0;\n    private currentQuestion: number = 0;\n    private questionText!: Phaser.GameObjects.Text;\n    private optionTexts: Phaser.GameObjects.Text[] = [];\n    private scoreText!: Phaser.GameObjects.Text;\n    private background!: Phaser.GameObjects.Image;\n\n    constructor() {\n        super({ key: 'MultChoiceScene' });\n    }\n\n    preload() {\n        this.load.image('background', 'assets/skies/space3.png');\n        this.load.image('button', 'assets/sprites/button-bg.png');\n        this.load.audio('correct', 'assets/audio/training-program-correct2-88734.mp3');\n        this.load.audio('wrong', 'assets/audio/buzzer-or-wrong-answer-20582.mp3');\n        this.load.image('home', 'assets/sprites/home_128x128.png');\n    }\n\n    create() {\n        this.background = this.add.image(400, 300, 'background');\n        \n        this.scoreText = this.add.text(16, 16, 'Score: 0', {\n            fontSize: '32px',\n            color: '#ffffff'\n        });\n\n        this.questionText = this.add.text(400, 200, '', {\n            fontSize: '24px',\n            color: '#ffffff',\n            align: 'center'\n        }).setOrigin(0.5);\n\n        // Type assertion for sound manager to access Web Audio API\n        const soundManager = this.sound as Phaser.Sound.WebAudioSoundManager;\n\n        // Add home button\n        this.controlPanel = new ControlPanel({\n            scene: this,\n            x: this.cameras.main.width,\n            y: 0,\n            width: 128,\n            height: 128,\n            padding: 20,\n            buttonSpacing: 10,\n            backgroundColor: 0x333333,\n            backgroundAlpha: 0.8\n        });\n        \n        this.controlPanel.addControl('home', () => {\n            this.scene.start('MenuScene');\n        }, 0.5);\n\n        this.displayQuestion();\n    }\n\n    private displayQuestion() {\n        if (this.currentQuestion >= FAMILYMC.length) {\n            this.gameOver();\n            return;\n        }\n\n        const question = FAMILYMC[this.currentQuestion];\n        this.questionText.setText(question.text);\n\n        // Clear existing option buttons\n        this.optionTexts.forEach(text => text.destroy());\n        this.optionTexts = [];\n\n        // Create new option buttons\n        question.options.forEach((option, index) => {\n            const optionText = this.add.text(400, 300 + (index * 50), option, {\n                fontSize: '20px',\n                color: '#ffffff',\n                backgroundColor: '#4a4a4a',\n                padding: { x: 10, y: 5 }\n            })\n            .setInteractive()\n            .setOrigin(0.5);\n\n            optionText.on('pointerdown', () => this.checkAnswer(index));\n            optionText.on('pointerover', () => optionText.setBackgroundColor('#666666'));\n            optionText.on('pointerout', () => optionText.setBackgroundColor('#4a4a4a'));\n\n            this.optionTexts.push(optionText);\n        });\n    }\n\n    private checkAnswer(selectedIndex: number) {\n        const question = FAMILYMC[this.currentQuestion];\n        \n        if (selectedIndex === question.correctAnswer) {\n            this.score += 10;\n            this.scoreText.setText(`Score: ${this.score}`);\n            this.sound.play('correct');\n        } else {\n            this.sound.play('wrong');\n        }\n\n        this.currentQuestion++;\n        setTimeout(() => this.displayQuestion(), 500);\n    }\n\n    private gameOver() {\n        this.questionText.setText(`Game Over!\\nFinal Score: ${this.score}`);\n        this.optionTexts.forEach(text => text.destroy());\n        \n        const restartButton = this.add.text(400, 400, 'Play Again', {\n            fontSize: '24px',\n            backgroundColor: '#4a4a4a',\n            padding: { x: 10, y: 5 }\n        })\n        .setInteractive()\n        .setOrigin(0.5)\n        .on('pointerdown', () => {\n            this.score = 0;\n            this.currentQuestion = 0;\n            this.displayQuestion();\n            restartButton.destroy();\n        });\n    }\n}\n",
    "src/scenes/AsteroidsScene.ts": "import { ControlPanel } from '../widgets/ControlPanel'\n\nexport class AsteroidsScene extends Phaser.Scene {\n    private controlPanel?: ControlPanel;\n    private debugEnabled: boolean = false;\n    private debugGraphics!: Phaser.GameObjects.Graphics;\n    private player!: Phaser.GameObjects.Sprite;\n    private asteroids: Array<{sprite: Phaser.GameObjects.Sprite; velocityX: number; velocityY: number}> = [];\n    private cursors!: Phaser.Types.Input.Keyboard.CursorKeys;\n    private score: number = 0;\n    private scoreText!: Phaser.GameObjects.Text;\n    private levelText!: Phaser.GameObjects.Text;\n    private gameOver: boolean = false;\n    private spawnTimer!: Phaser.Time.TimerEvent;\n    private level: number = 1;\n    private levelProgress: number = 0;\n    private levelThreshold: number = 1000; // Score needed to advance level\n\n    constructor() {\n        super({ key: 'AsteroidsScene' });\n    }\n\n    setDebug(enabled: boolean) {\n        this.debugEnabled = enabled;\n        // Always create debug graphics if enabled, even if it exists\n        if (this.debugEnabled) {\n            // Destroy existing debug graphics if it exists\n            if (this.debugGraphics) {\n                this.debugGraphics.destroy();\n            }\n            this.debugGraphics = this.add.graphics();\n            this.debugGraphics.setDepth(2);\n        }\n        console.log('Debug mode set to:', this.debugEnabled);\n    }    \n\n    init() {\n        // Make sure debug graphics is created if debug is enabled\n        if (this.debugEnabled && !this.debugGraphics) {\n            this.debugGraphics = this.add.graphics();\n            this.debugGraphics.setDepth(2);\n        }    \n    }\n\n    preload() {\n        this.load.image('ship', 'assets/sprites/thrust_ship2.png');\n        this.load.image('asteroid', 'assets/sprites/asteroids/a10004.png');\n        this.load.image('background', 'assets/skies/space3.png');\n        this.load.image('home', 'assets/sprites/home_128x128.png');\n    }\n\n    create() {\n        this.resetGameState();\n\n        const background = this.add.tileSprite(\n            this.cameras.main.centerX, \n            this.cameras.main.centerY, \n            this.cameras.main.width,\n            this.cameras.main.height,\n            'background'\n        );\n        \n        this.player = this.add.sprite(\n            this.cameras.main.centerX,\n            this.cameras.main.centerY,\n            'ship'\n        ).setDepth(1);\n\n        this.cursors = (this.input.keyboard as Phaser.Input.Keyboard.KeyboardPlugin).createCursorKeys();\n\n        // Add score and level display\n        this.scoreText = this.add.text(16, 16, 'Score: 0', {\n            fontSize: '32px',\n            color: '#ffffff'\n        });\n\n        this.levelText = this.add.text(16, 56, 'Level: 1', {\n            fontSize: '32px',\n            color: '#ffffff'\n        });\n\n        // Add home button\n        this.controlPanel = new ControlPanel({\n            scene: this,\n            x: this.cameras.main.width,\n            y: 0,\n            width: 128,\n            height: 128,\n            padding: 20,\n            buttonSpacing: 10,\n            backgroundColor: 0x333333,\n            backgroundAlpha: 0.8\n        });\n        \n        this.controlPanel.addControl('home', () => {\n            this.scene.start('MenuScene');\n        }, 0.5);\n        \n        this.startLevel();\n    }\n\n    private startLevel() {\n        // Adjust difficulty based on level\n        const spawnDelay = Math.max(1500 - (this.level * 100), 500); // Faster spawns each level, minimum 500ms\n        \n        this.spawnTimer = this.time.addEvent({\n            delay: spawnDelay,\n            callback: this.spawnAsteroid,\n            callbackScope: this,\n            loop: true\n        });\n\n        // Show level start text\n        const levelStartText = this.add.text(400, 300, `Level ${this.level}`, {\n            fontSize: '64px',\n            color: '#ffffff'\n        }).setOrigin(0.5);\n\n        // Remove the text after 2 seconds\n        this.time.delayedCall(2000, () => {\n            levelStartText.destroy();\n        });\n    }\n\n    update(time: number, delta: number) {\n        if (this.gameOver) {\n            return;\n        }\n\n        // Always clear and reset debug graphics if debug is enabled\n        if (this.debugEnabled) {\n            if (!this.debugGraphics) {\n                this.debugGraphics = this.add.graphics();\n                this.debugGraphics.setDepth(2);\n            }\n            this.debugGraphics.clear();\n            this.debugGraphics.lineStyle(2, 0x00ff00);\n        }\n\n        // Update score and check for level progression\n        this.score += delta * 0.01;\n        this.levelProgress += delta * 0.01;\n        this.scoreText.setText(`Score: ${Math.floor(this.score)}`);\n\n        // Check for level up\n        if (this.levelProgress >= this.levelThreshold) {\n            this.levelUp();\n        }\n\n        // Handle player movement\n        if (this.cursors.left.isDown) {\n            this.player.x = Math.max(this.player.x - 5, 50);\n        }\n        if (this.cursors.right.isDown) {\n            this.player.x = Math.min(this.player.x + 5, 750);\n        }\n        if (this.cursors.up.isDown) {\n            this.player.y = Math.max(this.player.y - 5, 50);\n        }\n        if (this.cursors.down.isDown) {\n            this.player.y = Math.min(this.player.y + 5, 550);\n        }\n\n        if (this.debugEnabled && this.debugGraphics) {\n            // Draw player bounds\n            const playerBounds = this.player.getBounds();\n            this.debugGraphics.strokeRect(\n                playerBounds.x,\n                playerBounds.y,\n                playerBounds.width,\n                playerBounds.height\n            );\n        }\n\n        // Update asteroids\n        for (let i = this.asteroids.length - 1; i >= 0; i--) {\n            const asteroidObj = this.asteroids[i];\n            const asteroid = asteroidObj.sprite;\n            \n            asteroid.x += asteroidObj.velocityX;\n            asteroid.y += asteroidObj.velocityY;\n\n            // In your update loop's asteroid section:\n            const asteroidBounds = asteroid.getBounds();\n            const scaledBounds = this.getScaledBounds(asteroid, 0.4);\n\n            if (this.debugEnabled && this.debugGraphics) {\n                // Draw original bounds in red\n                this.debugGraphics.lineStyle(2, 0xff0000);\n                this.debugGraphics.strokeRect(\n                    asteroidBounds.x,\n                    asteroidBounds.y,\n                    asteroidBounds.width,\n                    asteroidBounds.height\n                );\n\n                // Draw scaled bounds in yellow\n                this.debugGraphics.lineStyle(2, 0xffff00);\n                this.debugGraphics.strokeRect(\n                    scaledBounds.x,\n                    scaledBounds.y,\n                    scaledBounds.width,\n                    scaledBounds.height\n                );    \n            }\n\n            if (asteroid.x < -50 || asteroid.x > 850 || \n                asteroid.y < -50 || asteroid.y > 650) {\n                asteroid.destroy();\n                this.asteroids.splice(i, 1);\n            }\n\n            if (Phaser.Geom.Intersects.RectangleToRectangle(\n                this.player.getBounds(),\n                this.getScaledBounds(asteroid, 0.4)\n            )) {\n                this.handleGameOver();\n            }\n        }\n    }\n\n    private getScaledBounds(sprite: Phaser.GameObjects.Sprite, scale: number): Phaser.Geom.Rectangle {\n        const bounds = sprite.getBounds();\n        const widthDiff = bounds.width * (1 - scale);\n        const heightDiff = bounds.height * (1 - scale);\n        \n        return new Phaser.Geom.Rectangle(\n            bounds.x + (widthDiff / 2),\n            bounds.y + (heightDiff / 2),\n            bounds.width * scale,\n            bounds.height * scale\n        );\n    }\n\n    private levelUp() {\n        this.level++;\n        this.levelProgress = 0;\n        this.levelThreshold *= 1.2; // Increase threshold for next level\n        this.levelText.setText(`Level: ${this.level}`);\n\n        // Clear existing asteroids for a brief respite\n        this.asteroids.forEach(asteroidObj => asteroidObj.sprite.destroy());\n        this.asteroids = [];\n\n        // Stop current spawn timer\n        if (this.spawnTimer) {\n            this.spawnTimer.destroy();\n        }\n\n        // Start new level\n        this.startLevel();\n    }\n\n    private getRandomSpawnPosition(): { x: number; y: number; velocityX: number; velocityY: number } {\n        const side = Phaser.Math.Between(0, 3);\n        const baseSpeed = 3 + (this.level * 0.5); // Increase speed with level\n        const targetingProbability = Math.min(0.3 + (this.level * 0.1), 0.8); // Increases with level, caps at 80%\n        const isTargeting = Math.random() < targetingProbability;\n        let x, y, velocityX, velocityY;\n\n        switch(side) {\n            case 0: // top\n                x = Phaser.Math.Between(0, 800);\n                y = -50;\n                if (isTargeting) {\n                    velocityX = this.player.x - x;\n                    velocityY = this.player.y - y;\n                } else {\n                    velocityX = Phaser.Math.Between(-300, 300);\n                    velocityY = 300;\n                }\n                break;\n            case 1: // right\n                x = 850;\n                y = Phaser.Math.Between(0, 600);\n                if (isTargeting) {\n                    velocityX = this.player.x - x;\n                    velocityY = this.player.y - y;\n                } else {\n                    velocityX = -300;\n                    velocityY = Phaser.Math.Between(-300, 300);\n                }\n                break;\n            case 2: // bottom\n                x = Phaser.Math.Between(0, 800);\n                y = 650;\n                if (isTargeting) {\n                    velocityX = this.player.x - x;\n                    velocityY = this.player.y - y;\n                } else {\n                    velocityX = Phaser.Math.Between(-300, 300);\n                    velocityY = -300;\n                }\n                break;\n            default: // left\n                x = -50;\n                y = Phaser.Math.Between(0, 600);\n                if (isTargeting) {\n                    velocityX = this.player.x - x;\n                    velocityY = this.player.y - y;\n                } else {\n                    velocityX = 300;\n                    velocityY = Phaser.Math.Between(-300, 300);\n                }\n        }\n\n        const magnitude = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n        velocityX = (velocityX / magnitude) * baseSpeed;\n        velocityY = (velocityY / magnitude) * baseSpeed;\n\n        return { x, y, velocityX, velocityY };\n    }\n\n    private resetGameState() {\n        if (this.debugGraphics) {\n            this.debugGraphics.clear();\n        }        \n        this.asteroids.forEach(asteroidObj => asteroidObj.sprite.destroy());\n        this.asteroids = [];\n        this.score = 0;\n        this.gameOver = false;\n        this.level = 1;\n        this.levelProgress = 0;\n        this.levelThreshold = 1000;\n        \n        if (this.spawnTimer) {\n            this.spawnTimer.destroy();\n        }\n    }\n\n    private spawnAsteroid() {\n        if (this.gameOver) return;\n\n        const spawnData = this.getRandomSpawnPosition();\n        const asteroid = this.add.sprite(spawnData.x, spawnData.y, 'asteroid');\n        const baseScale = 0.5 + (Math.random() * 1.0); // Random size between 0.5 and 1.5\n        asteroid.setScale(baseScale);\n        asteroid.setDepth(1);\n\n        this.asteroids.push({\n            sprite: asteroid,\n            velocityX: spawnData.velocityX,\n            velocityY: spawnData.velocityY\n        });\n    }\n\n    private handleGameOver() {\n        this.gameOver = true;\n        this.spawnTimer.destroy();\n        \n        const gameOverText = this.add.text(400, 300, 'Game Over!', {\n            fontSize: '64px',\n            color: '#ffffff'\n        }).setOrigin(0.5);\n\n        const finalScore = this.add.text(400, 350, `Final Score: ${Math.floor(this.score)}`, {\n            fontSize: '32px',\n            color: '#ffffff'\n        }).setOrigin(0.5);\n\n        const levelReached = this.add.text(400, 390, `Level Reached: ${this.level}`, {\n            fontSize: '32px',\n            color: '#ffffff'\n        }).setOrigin(0.5);\n\n        const restartButton = this.add.text(400, 450, 'Play Again', {\n            fontSize: '32px',\n            backgroundColor: '#4a4a4a',\n            padding: { x: 10, y: 5 }\n        })\n        .setInteractive()\n        .setOrigin(0.5)\n        .on('pointerdown', () => {\n            this.scene.restart();\n        });\n    }\n}",
    "src/scenes/RobotEqScene.ts": "import { ControlPanel } from '../widgets/ControlPanel'\n\nexport class RobotEqScene extends Phaser.Scene {\n    // Declare class properties with proper types\n    private controlPanel?: ControlPanel;\n    private analyser!: AnalyserNode;\n    private dataArray!: Uint8Array;\n    private bufferLength!: number;\n    private graphics!: Phaser.GameObjects.Graphics;\n    private shader!: Phaser.GameObjects.Shader;\n\n    constructor() {\n        super({ key: 'RobotEqScene' });\n    }\n\n    preload() {\n        //this.load.setBaseURL('https://cdn.phaserfiles.com/v385');\n        this.load.video('robot', 'assets/video/robot-dance.webm');\n        this.load.audio('tune', 'assets/audio/aquakitty-kittyrock.m4a');\n        this.load.glsl('bundle', 'assets/shaders/bundle4.glsl.js');\n        this.load.image('home', 'assets/sprites/home_128x128.png');\n    }\n\n    create() {\n        const text = this.add.text(10, 10, 'Click to start', { \n            fontFamily: 'Courier',\n            fontSize: '16px',\n            color: '#00ff00'\n        });\n\n        // Type assertion for sound manager to access Web Audio API\n        const soundManager = this.sound as Phaser.Sound.WebAudioSoundManager;\n        \n        // Create audio analyzer\n        const analyser = soundManager.context.createAnalyser();\n        soundManager.masterVolumeNode.connect(analyser);\n        analyser.connect(soundManager.context.destination);\n        analyser.smoothingTimeConstant = 1;\n\n        this.bufferLength = analyser.frequencyBinCount;\n        this.dataArray = new Uint8Array(this.bufferLength);\n        this.analyser = analyser;\n\n        this.input.once('pointerdown', () => {\n            text.destroy();\n\n            this.sound.play('tune', { loop: true });\n            this.add.shader('GridBack', 512, 300, 1024, 600);\n            this.graphics = this.add.graphics();\n            this.add.video(512, 300, 'robot').play(true);\n        });\n\n        // Add home button\n        this.controlPanel = new ControlPanel({\n            scene: this,\n            x: this.cameras.main.width,\n            y: 0,\n            width: 128,\n            height: 128,\n            padding: 20,\n            buttonSpacing: 10,\n            backgroundColor: 0x333333,\n            backgroundAlpha: 0.8\n        });\n        \n        this.controlPanel.addControl('home', () => {\n            this.scene.start('MenuScene');\n        }, 0.5);\n\n        // Crerate shader\n        this.shader = this.add.shader('GridBack', 512, 300, 1024, 600);\n        this.graphics = this.add.graphics();\n\n        // Setup events for loss of browser focus - prevent tearing shader\n        this.game.events.on('hidden', () => this.onGameHidden());\n        this.game.events.on('visible', () => this.onGameVisible());\n        window.addEventListener('blur', () => this.onGameHidden());\n        window.addEventListener('focus', () => this.onGameVisible());\n    }\n\n    private onGameHidden() {\n        if (this.shader) {\n            this.shader.setActive(false);\n            this.shader.setVisible(false);\n        }\n    }\n\n    private onGameVisible() {\n        if (this.shader) {\n            this.shader.setActive(true);\n            this.shader.setVisible(true);\n        }\n    }\n\n    update() {\n        if (!this.graphics) {\n            return;\n        }\n\n        this.analyser.getByteTimeDomainData(this.dataArray);\n\n        this.graphics.clear();\n        this.graphics.lineStyle(2, 0x00ff00);\n        this.graphics.beginPath();\n\n        const sliceWidth = 1024 / this.bufferLength;\n        let x = 0;\n\n        for (let i = 0; i < this.bufferLength; i++) {\n            const v = this.dataArray[i] / 128;\n            const y = v * 300;\n\n            if (i === 0) {\n                this.graphics.moveTo(x, y);\n            } else {\n                this.graphics.lineTo(x, y);\n            }\n\n            x += sliceWidth;\n        }\n\n        this.graphics.lineTo(1024, 300);\n        this.graphics.stroke();\n\n        // Add home button\n        this.controlPanel = new ControlPanel({\n            scene: this,\n            x: this.cameras.main.width,\n            y: 0,\n            width: 128,\n            height: 128,\n            padding: 20,\n            buttonSpacing: 10,\n            backgroundColor: 0x333333,\n            backgroundAlpha: 0.8\n        });\n        \n        this.controlPanel.addControl('home', () => {\n            this.scene.start('MenuScene');\n            this.graphics.destroy();\n            this.sound.stopAll();\n        }, 0.5);\n    }\n\n    destroy() {\n        this.game.events.off('hidden');\n        this.game.events.off('visible');\n        window.removeEventListener('blur', this.onGameHidden);\n        window.removeEventListener('focus', this.onGameVisible);\n    }\n}",
    "src/scenes/MenuScene.ts": "import { MenuItemEnum, MenuItems, STARTMENU } from '../types/MenuItems';\n\nexport class MenuScene extends Phaser.Scene {\n    private demo_rectangle!: Phaser.GameObjects.Rectangle;\n    private menuTexts: Phaser.GameObjects.Text[] = [];\n    private startMenuData: MenuItems[];\n    private graphics!: Phaser.GameObjects.Graphics;\n    private shader!: Phaser.GameObjects.Shader;\n\n    constructor() {\n        super({ key: 'MenuScene'})\n        this.startMenuData = STARTMENU;\n    }\n\n    preload() {\n        // this.load.image ect, preload art / media\n        this.load.glsl('bundle', 'assets/shaders/bundle4.glsl.js');\n    }\n\n    create() {\n        // set this.background, text elments available on load\n        console.log('hello world!');\n        this.startMenuData = this.startMenuData.map((menuItem => {\n            if (menuItem.item === MenuItemEnum.RobotEqScene) {\n                return {\n                    ...menuItem,\n                    scene_key: 'RobotEqScene', // Assign data in main for abstraction\n                };\n            }\n            if (menuItem.item === MenuItemEnum.MultChoice) {\n                return {\n                    ...menuItem,\n                    scene_key: 'MultChoiceScene',\n                };\n            }\n            if (menuItem.item === MenuItemEnum.Asteroids) {\n                return {\n                    ...menuItem,\n                    scene_key: 'AsteroidsScene',\n                };\n            }\n            return menuItem; // leave others w defaults\n        }));\n        \n        // Crerate shader\n        this.shader = this.add.shader('GridBack', 512, 300, 1024, 600);\n        this.graphics = this.add.graphics();\n\n        // Setup events for loss of browser focus - prevent tearing shader\n        this.game.events.on('hidden', () => this.onGameHidden());\n        this.game.events.on('visible', () => this.onGameVisible());\n        window.addEventListener('blur', () => this.onGameHidden());\n        window.addEventListener('focus', () => this.onGameVisible());\n        \n        // Draw the menu\n        this.displayMenu();\n    }\n\n    private onGameHidden() {\n        if (this.shader) {\n            this.shader.setActive(false);\n            this.shader.setVisible(false);\n        }\n    }\n\n    private onGameVisible() {\n        if (this.shader) {\n            this.shader.setActive(true);\n            this.shader.setVisible(true);\n        }\n    }\n\n    update(time: number, delta: number) {\n        // This method is called once per game step while the scene is running.\n        // https://docs.phaser.io/api-documentation/class/scene\n        \n        // handle shader / graphics\n        //if (!this.graphics) {\n        //    return;\n        //}\n\n        //this.graphics.clear()\n\n    }\n\n    private displayMenu() {\n        this.menuTexts.forEach(text => text.destroy());\n        this.menuTexts = [];\n        this.startMenuData.forEach((option, index) => {\n            const menuText = this.add.text(400, 300 + (index * 50), option.text, {\n                fontSize: '20px',\n                color: '#ffffff',\n                backgroundColor: '#4a4a4a',\n                padding: { x: 10, y: 5}\n            })\n            .setInteractive()\n            .setOrigin(0.5);\n\n            menuText.on('pointerdown', () => console.log('change scene placeholder'));\n            menuText.on('pointerover', () => menuText.setBackgroundColor('#666666'));\n            menuText.on('pointerout', () => menuText.setBackgroundColor('#4a4a4a'));\n\n            if (option.scene_key !== undefined) {\n                menuText.on('pointerdown', () => {\n                    const msg = \"changing scene to \" + option.scene_key;\n                    console.log(msg);\n                    this.scene.start(option.scene_key);\n                });\n            }\n\n            this.menuTexts.push(menuText);\n        });\n    }\n\n    destroy() {\n        this.game.events.off('hidden');\n        this.game.events.off('visible');\n        window.removeEventListener('blur', this.onGameHidden);\n        window.removeEventListener('focus', this.onGameVisible);\n    }\n\n}"
  }
}